/*globals define*/
/*jshint node:true, browser:true*/

/**
 * Generated by PluginGenerator 0.14.0 from webgme on Sun Nov 22 2015 20:36:50 GMT-0600 (Central Standard Time).
 */

define([
    'plugin/PluginConfig',
    'plugin/PluginBase',
    'common/util/ejs',
    'plugin/NetworkRunner/NetworkRunner/Templates/Templates'
], function (
    PluginConfig,
    PluginBase,
    ejs,
    TEMPLATES) {
    'use strict';

    /**
     * Initializes a new instance of NetworkRunner.
     * @class
     * @augments {PluginBase}
     * @classdesc This class represents the plugin NetworkRunner.
     * @constructor
     */
    var NetworkRunner = function () {
        // Call base class' constructor.
        PluginBase.call(this);
    };

    // Prototypal inheritance from PluginBase.
    NetworkRunner.prototype = Object.create(PluginBase.prototype);
    NetworkRunner.prototype.constructor = NetworkRunner;

    /**
     * Gets the name of the NetworkRunner.
     * @returns {string} The name of the plugin.
     * @public
     */
    NetworkRunner.prototype.getName = function () {
        return 'NetworkRunner';
    };

    /**
     * Gets the semantic version (semver.org) of the NetworkRunner.
     * @returns {string} The version of the plugin.
     * @public
     */
    NetworkRunner.prototype.getVersion = function () {
        return '0.1.0';
    };

    /**
     * Main function for the plugin to execute. This will perform the execution.
     * Notes:
     * - Always log with the provided logger.[error,warning,info,debug].
     * - Do NOT put any user interaction logic UI, etc. inside this method.
     * - callback always has to be called even if error happened.
     *
     * @param {function(string, plugin.PluginResult)} callback - the result callback
     */
    NetworkRunner.prototype.main = function (callback) {
        // Use self to access core, project, result, logger etc from PluginBase.
        // These are all instantiated at this point.
        var self = this,
            nodeObject;
		// To see if your plugin is available:
        // localhost:<port>/api/plugins
        // If not - modify <yourrepo>/config/config.default.js
        // https://github.com/webgme/webgme/tree/master/config#plugin
        // Once available register the plugin on the root-node.
        // Write the ID in the field at PropertyEditor/Meta-tab/validPlugins.

        // Using the logger.
        // In the browser console you need to set
        // localStorage.debug = 'gme:*<NameOfPlugin>*'
        // For this plugin that would be:
        // localStorage.debug = 'gme:*CodeGenerator*'	
		
        //self.logger.debug('This is a debug message.');
        //self.logger.info('This is an info message.');
        //self.logger.warn('This is a warning message.');
        //self.logger.error('This is an error message.');
		

        // Using the coreAPI to make changes.

        nodeObject = self.activeNode;

        if (self.core.getPath(self.activeNode) === '' 
            ||self.isMetaTypeOf(self.activeNode, self.META.TaskScheduler) === false) 
			{
            callback('ActiveNode is not a valid model', self.result);
            return;
         }

        // We preload the entire subtree starting from the StateMachine.
        // By doing so we can use the get*Path(s) API calls rather than load*(s).
        // See https://github.com/webgme/webgme/wiki/GME-Core-API
        // and the WebGME slides.
        self.core.loadSubTree(self.activeNode, function (err, nodeList) {
            if (err) {
                callback(err);
                return;
            }

            // First we create a map from the nodePaths to the nodes.
            var i,
                nodePath,
                nodes = {};

            for (i = 0; i < nodeList.length; i += 1) {
                nodePath = self.core.getPath(nodeList[i]);
                nodes[nodePath] = nodeList[i];
                self.logger.info(nodePath);
            }

            // Get all the children of the StateMachine (States and Transitions)
            var childrenPaths = self.core.getChildrenPaths(self.activeNode);
            // Initialize the dataModel.
            var dataModel = {
                stateMachine: {
                    id: self.core.getPath(self.activeNode),
                    name: self.core.getAttribute(self.activeNode, 'name'),
                    initialStates: [],
                    finalStates: [],
                    states: [],
					flows:[]
                }
            }
            for (i = 0; i < childrenPaths.length; i += 1) {
                var childNode = nodes[childrenPaths[i]]; // Use the map to get the actual node from the path.
                self.logger.info(self.core.getAttribute(childNode, 'name'));

                // If the child is either a Initial- or Final-State we add this info to the data-model.
                if (self.isMetaTypeOf(childNode, self.META.Producer) === true) {
                    //dataModel.stateMachine.initialState = childrenPaths[i];
					dataModel.stateMachine.initialStates.push(childrenPaths[i]);
                } else if (self.isMetaTypeOf(childNode, self.META.Consumer)) {
                    dataModel.stateMachine.finalStates.push(childrenPaths[i]);
                }

                // For any state (including Initial and End) we want to find the transitions going out from it.
                if (self.isMetaTypeOf(childNode, self.META.StateBase)) {
                    // Initialize the data we are storing for each state.
                    var stateData = {
                        //id: childrenPaths[i],
                        name: self.core.getAttribute(childNode, 'name'),
                        transitions: [],
						
						avg_data_size: self.core.getAttribute(childNode, 'avg_data_size'),
						bandwidth_requirement:self.core.getAttribute(childNode, 'bandwidth_requirement'),
						processing_capacity:self.core.getAttribute(childNode, 'processing_capacity'),
						transactional_speed:self.core.getAttribute(childNode, 'transactional_speed'),
						
						attributes:[],
						improvements:[]
                    };
                    var j,
                        connectionPaths;
                    // This will gives us paths to all the transitions going out from the state. (One state can
                    // of course have multiple transitions going out from it).
                    // Look at the slides regarding connections and compare with this meta-model.
                    connectionPaths = self.core.getCollectionPaths(childNode, 'src');
					
					var attributeNames = self.core.getAttributeNames(childNode);
					console.log(attributeNames);
					stateData.attributes.push(attributeNames);
					
					var transactional_size= stateData.transactional_speed*stateData.avg_data_size;
					// processing_capacity must exceed transaction size
					if( 1.5*transactional_size>=stateData.processing_capacity ){
						stateData.processing_capacity=transactional_size*1.5;
						stateData.improvements.push("processing_capacity");
					}
					// bandwidth_requirement must meet with transaction size
					if(transactional_size>(2*stateData.bandwidth_requirement*1000/8) ){
						stateData.bandwidth_requirement=transactional_size/1000*8*2;
						stateData.improvements.push("bandwidth_requirement");					
					}
					
					// the unit of in_bandwidth and out_bandwidth are in KB					
					if (self.isMetaTypeOf(childNode, self.META.StreamProducer) === true) {
						var min_bandwidth_requirement= self.core.getAttribute(childNode, 'in_bandwidth')/1000;
						var out_bandwidth=self.core.getAttribute(childNode, 'out_bandwidth');
						if(out_bandwidth/2000>=min_bandwidth_requirement){
							min_bandwidth_requirement=out_bandwidth/2000;
						}
						stateData.improvements.push({"shard_num":min_bandwidth_requirement});
						if(min_bandwidth_requirement>stateData.bandwidth_requirement){
							stateData.bandwidth_requirement=min_bandwidth_requirement*1.1;
							stateData.improvements.push("bandwidth_requirement");
						}					
                    }

					
/* 					var attributeNameStr = [];
					var attributeValueStr = [];
					var attributeNameInstance = " ";
					var i;
					for(i=0;i<attributeNames.length;i+=1 ){

							attributeNameStr[i]=attributeNames[i];
							attributeNameInstance =toString(attributeNames[i]);
							attributeValueStr[i] = self.core.getAttribute( childNode,attributeNameInstance ); 							
					} 
					console.log(attributeNameStr);
					console.log(attributeValueStr);
					var jsonAttri = "{ ";
					for(var i = 0; i < attributeNameStr.length; i++) {
						(i + 1) == attributeNameStr.length ? jsonAttri += "\"" + attributeNameStr[i] + "\" : \"" + attributeValueStr[i] + "\"" : jsonAttri += "\"" + attributeNameStr[i] + "\" : \"" + attributeValueStr[i] + "\",";
					}
					jsonAttri += " }";
					var objAttri = JSON.parse(jsonAttri);
					console.log(objAttri); */
					
					

                    for (j = 0; j < connectionPaths.length; j += 1) {
                        var transitionNode = nodes[connectionPaths[j]]; // Again we use the node map to get the node.
                        // Initialize the transition data.
                        var transitionData = {
                            event: self.core.getAttribute(transitionNode, 'event'),
                            targetId: null,
                            targetName: null
                        };
						
						var attributesData = {};

                        // From the transition we get the destination (state) - a single transition only has one
                        // destination (and one source).
                        // Again look at the slides regarding connections and compare with this meta-model.
                        var targetPath = self.core.getPointerPath(transitionNode, 'dst');
                        var targetNode = nodes[targetPath];
                        transitionData.targetId = self.core.getPath(targetNode);
                        transitionData.targetName = self.core.getAttribute(targetNode, 'name');
                        stateData.transitions.push(transitionData);
						
                    }

                    dataModel.stateMachine.states.push(stateData);
                }


				
				// Get some information from the transitions(dataflows)
                if (self.isMetaTypeOf(childNode, self.META.DataFlow)) {
                    // Initialize the data we are storing for each state.
                    var flowData = {
                        id: childrenPaths[i],
                        //name: self.core.getAttribute(childNode, 'name'),	
						
						flowLebel: self.core.getAttribute(childNode, 'event'),
						bandwidth:self.core.getAttribute(childNode, 'bandwidth'),
						state:self.core.getAttribute(childNode, 'state'),

						improvements:[]
                    };

                    dataModel.stateMachine.flows.push(flowData);
                }
				
            }
            // Convert the gathered data to a string.
            var dataStr = JSON.stringify(dataModel, null, 4);
            self.logger.info(dataStr);
            // Up to this is the point - we covered at the lecture.

            // Now we want to upload the generated json as a file (blob) on the server and
            // generate a link to it in the plugin-result.
            
            // If you'd like to generate code. Take a look at the templates at
            // https://github.com/webgme/webgme-fsm/tree/master/src/plugins/FSMCodeGenerator
            // The dataModel we created contains all the info to generate an executeable StateMachine.
            
            var artifact = self.blobClient.createArtifact('taskscheduler');
            // Upload the files to server.
            artifact.addFile('model.json', dataStr, function (err) {
                if (err) {
                    callback(err);
                    return
                }
                // Save the artifact (uploads meta data about the file(s) within in it).
                artifact.save(function (err, hash) {
                    if (err) {
                        callback(err);
                        return
                    }

                    // Add a link to the artifact to the plugin-result.
                    self.result.addArtifact(hash);

                    self.result.setSuccess(true);
                    callback(null, self.result);
                })
            });
        });

        return;
    };

    return NetworkRunner;
});